---
title: "C++20スマートポインタ入門"
source: "https://qiita.com/hmito/items/9b35a2438a8b8ee4b5af"
author:
  - "[[hmito]]"
published: 2022-06-22
created: 2025-08-21
description: "概要 本記事は、C++11スマートポインタ入門の内容を全体的に見直し、C++20時点での規格に合わせて情報を加筆したものです。C++20までの変更点を知りたい方は、色付き部分のみ追いかけていただけると幸いです。 皆さんは、メモリの動的確保に関連したトラブルに遭遇し..."
tags:
  - "clippings"
---
![](https://relay-dsp.ad-m.asia/dmp/sync/bizmatrix?pid=c3ed207b574cf11376&d=x18o8hduaj&uid=)

この記事は最終更新日から1年以上が経過しています。

## 概要

本記事は、 [C++11スマートポインタ入門](https://qiita.com/hmito/items/db3b14917120b285112f) の内容を全体的に見直し、C++20時点での規格に合わせて情報を加筆したものです。C++20までの変更点を知りたい方は、色付き部分のみ追いかけていただけると幸いです。

皆さんは、メモリの動的確保に関連したトラブルに遭遇したことはないでしょうか？　 `nullptr` で初期化するのを忘れていた、気がつけばメモリが確保されていない、うっかり `delete` し忘れてメモリリークを起こした・・・etc... これらはいずれも、 `new/delete` を使って動的メモリを手動管理していることに起因するトラブルです。

実は、最近のC++では、 **メモリの動的確保に際して、 `new/delete` を書く必要はほとんどありません。** 多くの場合、スマートポインタがそれらの作業を代替してくれるからです。

この記事では、初めてスマートポインタについて学ぶ人を対象に、C++に用意されている3種のスマートポインタの機能と使い方、およびそれらの使い分けについて解説します。

## スマートポインタって？

### 動的メモリは危険がいっぱい

C++の教科書では、決まってメモリの動的確保には `new` `delete` を使うとあります。が、これらをミスなく使いこなすのは少々厄介です。

例えば、引数 `len` の長さのint型配列を確保して使用する関数を考えてみます。以下のコード、問題山積みなんですが、何がやばいかわかりますか？

```c++
void func(int len){
   int* ptr;

   //lenが0より大きいとき、その長さのメモリを確保
   if(len > 0){
      ptr = new int[len];
   }

   //ptrを使って計算
   for(int i = 0; i<len; ++i){
      ptr[i] = i*i;
   }
}
```

そうです、 `delete` し忘れているので、メモリの解放忘れ＝「メモリリーク」が起きています。

では、 `delete` を追記すればOKでしょうか？

```diff_cpp
void func(int len){
   int* ptr;

   //lenが0より大きいとき、その長さのメモリを確保
   if(len > 0){
      ptr = new int[len];
   }

   //ptrを使って計算
   for(int i = 0; i<len; ++i){
      ptr[i] = i*i;
   }
+
+   //メモリを解放
+   delete[] ptr; // <--- new!!
}
```

C++では、 `new` していないポインタやすでに解放したメモリに対する `delete` は、未定義動作を引き起こします。 `len` が0以下の時、 `ptr` はそもそも `new` したメモリを保持していないので、 `delete` を実行すると一発アウトです。

ではでは、 `ptr` の中身に応じて `delete` するか条件分岐をつければいいでしょうか？

```diff_cpp
void func(int len){
   int* ptr;

   //lenが0より大きいとき、その長さのメモリを確保
   if(len > 0){
      ptr = new int[len];
   }

   //ptrを使って計算
   for(int i = 0; i<len; ++i){
      ptr[i] = i*i;
   }

   //メモリを解放
+   if(ptr){
       delete[] ptr;
+   }
}
```

このコード、そもそも `ptr` が初期化されておらず、何が入っているかわからない状況です。つまり、 `len` が0以下でも、たまたま `if(ptr)` がtrueとなることで、 `new` されていないptrに対して `delete[]` が実行されてしまう可能性が残っています。こうした問題を避けるため、本来は `int* ptr = nullptr;`と明示的に初期化すべきです。

上記の例はシンプルな関数なので誤りを見つけやすいですが、メモリの確保から解放までの間に多くの処理が入るとどうでしょう？　 `for` 、 `if` の複雑な組み合わせやオブジェクト間でのメモリのやり取りの中で動的メモリを管理しなければいけないとしたら？

**構造が複雑化するほど、メモリの動的確保を完璧に管理するのは困難になります** 。タチの悪いことに、これらメモリが関わるバグはコンパイル時に検出するのが難しいことが多く、「実行中たまにプログラムが落ちる」というような極めて原因究明が面倒な事態にもなりかねません。

### スマートポインタとは？

上で書いたトラブルは、確保した動的メモリを管理する『責任者』がいないことが原因と言えます。「今メモリを保持しているか」を常に管理し、「必要無くなればメモリを解放」してくれるような動的メモリの『責任者』がいれば、こんなトラブルは起きないはずです。

実は、この **動的メモリを管理する『責任者』の役割を果たすクラスこそがスマートポインタ** です。

スマートポインタでは、 **メモリの所有権** という概念でメモリ管理を行なっています。簡単に言ってしまうと、所有権を持つ ＝「そのメモリにアクセスする権利と、解放する義務」です。所有権は他のスマートポインタに渡したり、共同所有したりすることはできますが、所有権が消えてなくなることはありません。そして、自身が破棄される時、すなわちディストラクタが呼ばれる際に、もし自分が保有するメモリの唯一の所有者なら、そのメモリを解放します。つまり、 **確保したメモリ毎に所有権を設定して責任者を決める** ことで、勝手にメモリが解放されるのを防ぎ、同時にメモリの解放忘れや不適切なメモリの解放を防いでいるわけです。

もっとも、スマートポインタの利用時にはこうした概念を意識する必要はありません。重要なことは、 **スマートポインタにメモリを委ねてしまえば、 初期化から解放まで動的メモリ管理を一切気にする必要がなくなる** ということです。

### 実際に使ってみる

先ほどの例を、スマートポインタを使って書き直してみましょう。なお使用する際には `<memory>` ヘッダをincludeする必要があります。

```diff_cpp
+#include <memory>
void func(int len){
-   int* ptr;
+   std::unique_ptr<int[]> ptr;

   //lenが0より大きいとき、その長さのメモリを確保
   if(len > 0){
-     ptr = new int[len];
+     ptr = std::make_unique<int[]>(len);
   }

   //ptrを使って計算
   for(int i = 0; i<len; ++i){
      ptr[i] = i*i;
   }

-   //メモリを解放
-   if(ptr){
-       delete[] ptr;
-   }
}
```

書き換えが必要なのはこれだけです。ポインタの宣言と代入をスマートポインタ用のものに書き換えるだけです。 `new` も `delete` もないので、本当に動的メモリ確保が行われているのか不安になりますが、内部で行われていることは非常に単純です。

まず、コンストラクタ内でポインタの初期化が自動的に行われます。

```cpp
std::unique_ptr<int[]> ptr;
//こう書くのと同じ
//int* ptr=nullptr;
```

メモリの確保はmake\_unique関数が内部で処理してくれています。

```cpp
ptr = std::make_unique<int[]>(len);
//make_unique関数内部でnewしている
//ptr = new int[len];
```

アクセス方法は普通のポインタと基本的に同じです。さすがにインクリメントやディクリメントによる参照先の移動はできませんが、 `*` や `->` 、配列型なら `[]` によるアクセスが可能です。

```cpp
//配列型ならoperator[]で要素にアクセスできる
for(int i = 0; i<len; ++i){
   ptr[i] = i*i;
}
```

`delete` に相当する処理は明確に記述しなくても、ディストラクタが呼ばれた際に所有権を持つメモリは自動的に解放してくれています

```cpp
void func(int len){
   std::unique_ptr<int[]> ptr;
   ...
} //　ここでptrのディストラクタが呼ばれる
  //　ptrがメモリを保持していれば、自動的にdeleteで解放される
```

このように、スマートポインタに置き換えるだけで上記で指摘したような、 **ポインタの初期化忘れ、メモリの解放忘れや、不適切な対象への `delete` の実行** といったトラブルを防ぐことができるのです。

## スマートポインタの種類

C++11以降のC++には、所有権の持つ性質の違いから、3種類のスマートポインタが用意されています。

`unique_ptr` は、その名の通りあるメモリの **所有権はただ一つのインスタンスが保持** するよう設計されたスマートポインタです。軽量・シンプルで生のポインタに比べても基本的にパフォーマンス上のオーバーヘッドなしに使えます。ただし、所有権は常に単一のインスタンスが保持する以上、コピーはできずムーブ（所有権の移動）のみが可能です（ムーブについては [ムーブセマンティクス](http://yohhoy.hatenablog.jp/entry/2012/12/15/120839) や [右辺値参照](http://cpplover.blogspot.jp/2009/11/rvalue-reference_23.html) などの記事をご参照ください）。

`shared_ptr` は、その名の通りあるメモリの **所有権を複数のインスタンスで共有** できるように設計されたスマートポインタです。最大の特徴はコピー可能なことです。コピーされた場合、所有権は複数のインスタンスで共有され、メモリの解放は最後に所有権を持つインスタンスによって行われます。ただし、この所有権を共有する仕組みのために、生のポインタに比べて（たとえコピーしなくても！）パフォーマンス面で若干のオーバーヘッドが存在します。

`weak_ptr` は、自身ではメモリへの所有権は持たず、代わりに **`shared_ptr` の持つメモリへの参照を保持** します。所有権を持たないため、知らない間に参照先のメモリが解放されてしまう場合もありますが、「まだ参照先のメモリが解放されいないか」を確かめることができる関数と、shared\_ptrへと昇格することで参照先の所有権を確保する機能を持っています。

まとめるとこんな感じです。

| 型名 | コピー | ムーブ | アクセス | 所有権 | 特徴 |
| --- | --- | --- | --- | --- | --- |
| unique\_ptr | × | ○ | ○ | 単一 | 軽量・シンプル |
| shared\_ptr | ○ | ○ | ○ | 共有 | コピー可能だがオーバーヘッドが存在 |
| weak\_ptr | ○ | ○ | △ | \- | 所有権を持たずshared\_ptrへの参照を保持 |

以下では、具体的にこれら3つのスマートポインタの使い方について紹介していきます。

## スマートポインタの基本的な使い方

まずは基本となるスマートポインタである、 `unique_ptr` と `shared_ptr` の使い方についてみてみましょう。

### メモリの管理を委ねる

スマートポインタにメモリの所有権を委ねるには、コンストラクタで指定するか、 `reset(pointer)` を使います。

ただし、同等の処理は `make_unique<T>` 、 `make_shared<T>` 関数を使った方が簡単で間違いがありません。例えば、上記の処理は以下のように書き直せます。

make\_uniqueはC++14以降で使用可能です。

`make_unique<T>` 、 `make_shared<T>` 関数は、コンストラクタが複数の引数をとるようなクラスの場合でも使えます。

`new` を手動で呼ぶこと自体がトラブルの原因となりうるので、特に理由がない限り `make_unique<T>` 、 `make_shared<T>` 関数を使いましょう！

### メモリにアクセスする

メモリの所有権を実際に保持しているかは、 `operator bool()` 、つまりbool型の文脈で使用することで判定できます。所有権を持つ場合にはtrue、持たない場合にはfalseを返します。

ポインタの保持するメモリにアクセスするには、通常のポインタ同様に `operator*()` や `operator->()` を使用します。

`get` 関数を使うことで、所有権を保持するメモリのアドレス（生ポインタ）を取得することができます。ただし、この関数を実行してもメモリの所有権はスマートポインタが保持したままです。

### 所有権を移動する

ムーブを使って所有権の移動を行うことができます。

移動先がすでに別のメモリを管理していた場合でも、古いメモリは自動的に解放されるので安心です。

もちろん、swapだって使えます。

関数の戻り値として使うこともできます。

```c++
std::unique_ptr<std::string> hello(int num){
   std::string str;
   for(int i = 0; i<num; ++i){
      str += "hello!";
   }
   return std::make_unique<std::string>(str);
}

auto response = hello(4);
//"hello!hello!hello!hello!"が入ったunique_ptrが帰ってくる
```

生のポインタ同様、暗黙の型変換が可能なポインタ同士であれば、異なる型間でも所有権を移動することが出来ます。

なお、 `unique_ptr` から `shared_ptr` へと所有権を移動することも可能です。残念ながら、 `shared_ptr` から `unique_ptr` へと所有権を移動する方法はありません。

### メモリを解放する

メモリの解放は、放っておいてもディストラクタで行われますので、使用上意識する必要はありません。

もちろん、他の代入されたり `reset()` 関数で新たなメモリが割り当てられた場合でも、古いメモリはきちんと解放されます。

明示的に解放したい場合は引数なしで `reset()` 関数を呼ぶことで実現できます。

### 配列型を扱う

`unique_ptr<T[]>` や `shared_ptr<T[]>` のように指定すれば、配列を扱うこともできます。

なお、配列の場合でも `make_unique<T[]>` 関数を使って作成できます！　この場合、引数は確保する配列長になります。

配列型の場合、 `operator` によって配列のようにアクセスすることができます。

## unique\_ptrとshared\_ptrの違い

ここまでみてきたように、 `unique_ptr` と `shared_ptr` の間では、ほとんど同じ使い方ができますが、名前の通り所有権をめぐる考え方の違いから、いくつかの機能が異なっています。

### コピーの可否

所有権を単一のインスタンスが保持する設計の `unique_ptr` では、コピーは禁止されています。これは、コピーできてしまうと、コピー先とコピー元のどちらが所有権を持っているのか分からなくなってしまうためです。

```cpp
auto ptr = std::make_unique<int>(10);

//コピーコンストラクタや、コピー代入演算子はエラー
std::unique_ptr<int> ptr2(ptr); //Compile ERROR
std::unique_ptr<int> ptr3;
ptr3=ptr;   //Compile ERROR
```

一方、所有権を複数のインスタンスで共有可能な設計の `shared_ptr` は、コピーが可能です。所有権はコピー先とコピー元の両者が共有し、そのメモリに対して所有権を持つ最後のインスタンスが消えるまでメモリは解放されません。

### 所有権の放棄

`unique_ptr` には、保有するメモリの所有権を放棄する `release()` 関数が存在します。 `release()` を行うと、そのメモリの解放は手動で行う必要があります。

```cpp
auto ptr = std::make_unique<int>(10);

//所有権を放棄する場合は、release関数を使う
//戻り値で管理していたメモリのポインタが帰ってくる
int* pint = ptr.release();

//当然、メモリの解放自体は自分で行う必要がある
delete pint;
```

動作はget関数と類似していますが、get関数では所有権自体は放棄しない点に注意が必要です。

一方、 `shared_ptr` には所有権を放棄するための関数はありません。

## weak\_ptrの使い方

3つめの `weak_ptr` は、必ず `shared_ptr` と共に使ういわば補助的役割のスマートポインタです。 `weak_ptr` の機能を説明する前に、 `shared_ptr` が原因で生じる、循環参照と呼ばれる厄介な状態について説明します。

### 循環参照

例えば、以下のようなwomanとman、二つのクラスを考えてみます。それぞれは、自身のパートナーをメンバ変数として `shared_ptr` で管理していおり、make\_partner関数を呼ぶことで互いをパートナーとして登録します。

womanがmanを、manがwomanを `shared_ptr` で持ち合う、やや特殊な設計ですが、少なくともメモリ管理に関しては、一見何の問題もないコードのように見えます。ところが、実はこの例では、 **`shared_ptr` で管理されているメモリが正しく解放されず、メモリリークが発生します** 。

なぜスマートポインタで管理しているのに、メモリリークが発生するのでしょう？ make\_partner後、Aliceのために確保されたメモリはAlicePtrとBob.partnerの二つ、BobのメモリはBobPtrとAlice.partnerの二つの `shared_ptr` に所有権を持たれた状態となっています。main関数が終了する際、AlicePtrのデストラクタが呼ばれます。ところが、Bob.partnerがまだ所有権を保持し居てるため、Aliceはこの時点で解放されません。次に、BobPtrのデストラクタが呼ばれますが、今度は解放されずに残っているAliceが保持するAlice.patnerがまだ所有権を保持しているため、Bobもこの時点でも解放されません。結果、 **AliceとBobのメモリは、最初に所有していたAlicePtr、BobPtrそれぞれのデストラクタが呼ばれたにもかかわらず、解放されずに残ってしまう** ことになります。これが、 **循環参照** と呼ばれる現象です。

循環参照自体は、クラスが単一でも生じる現象です。例えば、以下のクラスの例では、うっかり自身を次のタスクとして登録すると循環参照が発生し、Taskのメモリが解放されない事態になります。

なお本筋から外れますが、このコードでTask->do\_task()を呼び出すと無限再起（do\_task内で自分自身であるdo\_taskを呼び出し、その中でさらにdo\_taskを呼び出し・・・）となるため、いずれにせよ問題が生じます。

### 所有せず参照する：weak\_ptr

`weak_ptr` は、循環参照を防ぐために導入されたスマートポインタです。先の二つのスマートポインタと違い、 `weak_ptr` は **メモリへの所有権を持つことはありません** 。代わりに、 `weak_ptr` は **`shared_ptr` の指すメモリを参照することができます** 。

先ほどの循環参照の例で見てみます。

変わったのは、man, womanクラスがそれぞれpartnerを `shared_ptr` ではなく `weak_ptr` で保持するようになった点です。これだけの違いですが、Alice,Bobのデストラクタが呼ばれた際にそれぞれ互いの所有権を持たなくなるため、循環参照が生じずメモリは正しく解放されるようになります。

このように、 `weak_ptr` は **所有権を持たずに メモリへの参照のみ保持する** スマートポインタです。所有権を持たないため、自身の参照先のメモリが解放されてしまうことはありますが、循環参照によるメモリリークを防ぐことが出来ます。

以下で詳しい `weak_ptr` の使い方を見ていきましょう。

### shared\_ptrのメモリを参照させる

他のスマートポインタ同様、メモリを管理させるにはコンストラクタ、代入演算子、あるいは `reset()` 関数を使います。ただし、 `weak_ptr` は `shared_ptr` が所有権を持つメモリしか管理できないため、生のポインタを受け取ることはできません。

### 一時的に所有権を取得する

所有権を保持していないので、 `operator*()` や `operator->()` などを使って、 `weak_ptr` から直接参照先のメモリにアクセスすることはできません。メモリにアクセスするには、まず `lock()` によってそのメモリへの所有権を保持する `shared_ptr` を一時的に取得し、そこからアクセスする必要があります。このような設計になっているのは、メモリへの使用中に解放されてしまう事態を避けるためです。

なお、 `lock()` 時点で `weak_ptr` の参照先のメモリが解放されていた場合、空の `shared_ptr` が帰ってきます。このことを利用して、実用上は以下のようにif文と組み合わせて使うと良いでしょう

なお、参照先のメモリがすでに解放されてしまっているかは、 `expired()` を使って確認することができます。戻り値がtrueであれば、すでに解放されてしまっています。 `operator bool()` は用意されていません。

ただし、 `lock()` できるかを確認する目的で、 `expired()` を使うのはお勧めしません。マルチスレッド環境では、 `expired()` の戻り値がたとえfalseでも、 `lock()` 時点ではすでに解放されてしまっているケースが考えられるためです。

そもそも、前述の通り `lock()` できない場合は空の `shared_ptr` が帰ってくるので、事前確認は不要です。

`expired()` の使い所としては、たとえば複数の `weak_ptr` を管理している際に、参照先が無効となったものから取り除くような、ガベージコレクション的使い方でしょうか。

```c++
std::vector<std::weak_ptr<int>> Watchers; //監視対象を覚えておく配列

while(true){
   ... //Watchersへの登録など、必要なループ処理
   
   //参照先がなくなったweak_ptrをクリーンアップする
   auto End = std::remove_if(
      Watchers.begin(),Watchers.end(),
      {return wptr.expired();}
   );
   //実際に配列から削除
   Watchers.erase(End,Watchers.end());
}
```

### weak\_ptrのコピーとムーブ

`weak_ptr` は、コピー、ムーブともに使用することができます。

### 参照をやめる

明示的に参照を終えたい場合は、 `reset()` を呼び出すことで実現できます。

## スマートポインタをうまく活用しよう

さて、ここまで3種類のスマートポインタの使い方についてみてきました。それでは、どうこの3種を使い分ければよいのでしょう？　もっといえば、既存の生のポインタで書かれたコードを、どのようにスマートポインタに置き換えればよいのでしょう？

これを考えるためには、まず「所有」のためのポインタと「参照」のためのポインタを区別する必要があります。「所有」とは、自身がメモリの寿命をコントロールする、ということです。「所有」している限りはメモリは解放されないことが保証される代わりに、 **自身が所有権を手放さない限りそのメモリは解放されることがない** わけです。一方、単にアクセスするためだけにアドレスが一時的に必要なだけであれば、それは「参照」です。メモリの寿命に関与することはありませんが、同時にそれは知らない間に解放される可能性を意味します。このため、「参照」は原則として所有者より内側のスコープなど、 **参照を使っている間は解放されないことが保証されているケース** でのみ使うべきです。

もちろん、スマートポインタによって書き変えるべきポインタは、「所有」のためのポインタです。

「参照」は言語機能としての参照、つまり `T&` と書き変えることが出来る、と言い換えてもいいかもしれません。ただし、生ポインタによる「参照」は、 `nullptr` によって空の状態を表現できる、他のアドレスを代入できる、インクリメント・デクリメントなどの処理ができます。このため、「参照」のポインタであっても、常に `T&` で書き変えられるわけではないでしょう。この辺りについては、別の入門記事である [「それ、ポインタ使わなくてもできるよ：Ｃ言語のポインタとC++の流儀」](https://qiita.com/hmito/items/44925fca9fca74e78f61) をご覧ください

スマートポインタを使う上では、基本的には `unique_ptr` を第一の選択肢とすべきです。コピーができない、というところに不自由さを感じるかもしれませんが、そもそも「所有権のコピー」が必要となるのはまれです。関数の引数などアクセスするための「参照」が欲しいだけなら、 `operator*` でオブジェクトの実体を渡すか、 `get()` 関数でアドレスを取得して引き渡せば済みます。また、関数の戻り値や関数への引き渡し、オブジェクト間のやり取りなど、所有権の「移動」であれば、ムーブで表現可能です。多くの場合、メモリの動的確保は `unique_ptr` を使っておけば間違いないでしょう。

一方、 `shared_ptr` を使うべきケースは大きく二つに分かれます。一つは、複数のオブジェクトで「所有」する必要があるケースです。(1) 複数のオブジェクトで単一の共有リソースを同時に使用する必要があり、(2) それぞれのオブジェクトの寿命はケースバイケースで誰が一番長生きするかは決められず、(3) 共有リソースは全てのオブジェクトの寿命が尽きれば速やかに開放したい、  
といったケースでは、 `shared_ptr` を使って共同所有させるのが自然でしょう。

裏を返せば、上記のいずれかの条件が満たされなければ、 `unique_ptr` でも十分かもしれません。例えば、リソースの使用が同時ではなく順繰りなのであれば、 `move` によって所有権をオブジェクト間で移していけばよいかもしれません。あるオブジェクトの寿命が常に最も長いと保証できるケースでは、そのオブジェクトが `unique_ptr` で「所有」し、他のオブジェクトには「参照」で渡せばよいでしょう。共有リソースの解放が多少遅れてもよいなら、より上位のスコープで `unique_ptr` で確保＆管理してもよいわけです。

`shared_ptr` を使うべきもう一つのケースは、相手が解放されてしまう可能性のある「参照」を作りたい場合です。前述の通り、原則的には「参照」を使っていいのは相手が使用中に解放されないことが保証できるケースで、それが保証できないなら「所有」を使うべきです。しかし、(1)自身がメモリの寿命には影響を与えたくないが、(2)相手が解放されている可能性が保証できないケース、というのも稀にあり得ます。そういったケースでは、所有権を複数のオブジェクトで共有する必要がなくとも、 `shared_ptr` でメモリを管理し、 `weak_ptr` で「参照」を他のオブジェクトに渡す、というのはあり得る設計です。

`shared_ptr` は一見便利ですが、パフォーマンス上のコストに加えて循環参照のリスクがあります。「所有」のポインタとして `shared_ptr` を選択する場合は、可能な限り `weak_ptr` を使うなどリスクを回避した設計にすることをお勧めします。

## 補足：deleterの指定

特殊なケースでは、メモリ解放に際して `delete` 以外の処理を行う必要がある場合もあるかもしれません。例えば、メモリはある関数を介して必ず確保、解放しなければいけない状況を考えてみます。

```cpp
//int型のリソースをstorageから確保する
int* malloc_int_from_storage();
//int型のリソースをstorageから解放する
void free_int_from_storage(int* ptr);
```

このような場合、メモリの解放には `delete` ではなく、 free\_int\_from\_storage関数を使いたくなります。

deleterとは、このようなメモリ解放時の処理を指定する関数オブジェクトです。 `unique_ptr` 、では、第二テンプレート引数に指定することで、deleterを指定することができます。

```cpp
//free_int_from_storageを使ってメモリを解放する関数オブジェクトを定義する。
struct deleter_for_storage{
   void operator()(int* ptr_){
      free_int_from_sotrage(ptr_);
   }
};
int main(){
   //テンプレート第二引数で、deleterを指定する
   std::unique_ptr<int, deleter_for_storage> uptr(malloc_int_from_storage());

   return 0;
}//deleteではなく、free_int_from_storageがメモリ解放の際に呼ばれる。
```

`shared_ptr` の場合、deleterをテンプレート引数で指定することはできませんが、コンストラクタに入れることで指定することができます。

deleterを明示的に指定してやれば、 `new` 以外の方法で確保したメモリや、メモリ以外のリソースについても `unique_ptr<T>` を用いて管理することができるわけです。

## 参考文献

[cppreference.com](http://en.cppreference.com/w/cpp)  
[cpprefjp - C++ Reference Site](https://sites.google.com/site/cpprefjp/)

[3](https://qiita.com/hmito/items/#comments)

コメント一覧へ移動

X（Twitter）でシェアする

Facebookでシェアする

はてなブックマークに追加する

新規登録して、もっと便利にQiitaを使ってみよう

1. あなたにマッチした記事をお届けします
2. 便利な情報をあとで効率的に読み返せます
3. ダークテーマを利用できます
[ログインすると使える機能について](https://help.qiita.com/ja/articles/qiita-login-user)

[新規登録](https://qiita.com/signup?callback_action=login_or_signup&redirect_to=%2Fhmito%2Fitems%2F9b35a2438a8b8ee4b5af&realm=qiita) [ログイン](https://qiita.com/login?callback_action=login_or_signup&redirect_to=%2Fhmito%2Fitems%2F9b35a2438a8b8ee4b5af&realm=qiita)

[306](https://qiita.com/hmito/items/9b35a2438a8b8ee4b5af/likers)

いいねしたユーザー一覧へ移動

249