---
title: "わい、static変数とstaticメソッドについて熱く語る"
source: "https://qiita.com/Nekonecode/items/19f3a261a8391853ddec"
author:
  - "[[Nekonecode]]"
published: 2019-06-14
created: 2025-11-26
description: "はじめに 昨今、プログラマーと会話をしていると staticをつけた変数はクラス内で共有されるとか staticをつけたメソッドはどこからでも呼べるとか そのくらいの理解はしているけど、結局staticってよくわかんないんだよね というプログラマーがちょくちょくいるなぁと..."
tags:
  - "clippings"
---
![](https://relay-dsp.ad-m.asia/dmp/sync/bizmatrix?pid=c3ed207b574cf11376&d=x18o8hduaj&uid=)

この記事は最終更新日から5年以上が経過しています。

## はじめに

昨今、プログラマーと会話をしていると

staticをつけた変数はクラス内で共有されるとか  
staticをつけたメソッドはどこからでも呼べるとか

そのくらいの理解はしているけど、結局staticってよくわかんないんだよね

というプログラマーがちょくちょくいるなぁと思ったので  
徹底的に解説してみよう！

と意気込んだものの  
徹底的にとなるとめっちゃボリュームあって書くの疲れちゃうな  
と思ったので

なんとなく暗記で覚えてる人が  
もう、ちょっと視点を変えてstaticを捉えられる  
くらいの雑な記事を書いてみた次第です。

## 追記：動画も作りました

- [Static変数](https://youtu.be/KKnrMxAJkAc)
- [Staticメソッド](https://youtu.be/7W66lYH2aCQ)

## 対象読者

ある程度プログラムかけるようになってきたけど  
初心者に毛が生えたくらいのレベルだなと感じている人  
staticは使うし使えるけど、どこかモヤっとしている人

## ちな経歴

最初はWEBから入ってHTML、CSS、JS、PHPを3~4年  
並行してVBとC#もやってました。(ASP.NETで結局WEB)

プログラム歴4年くらいのころに  
WEBは作れるけどゲームとかどうやって作るのか検討もつかない  
と思いゲーム系の専門学生へ身を転じ、そのままゲーム業界へ

ゲーム開発は基本C++で、合計5年くらいC++をやってました。  
幸か不幸かミリオンタイトルのリーダー兼リードプログラマーに任命され  
恥ずかしながらちょっとドヤっていた時期もありました。

その後ゲーム開発にも飽き、フリーランス→講師→ベンチャーなどをへて  
現在は最近流行りの **引きこもり** をやっています。

話がそれたので戻します。

## 「staticってそういうもんだったのか！」ってなった時期

プログラム歴６年とか、そのくらいの時期だったかなと思います。

長い事「staticはよくわからんけど使えりゃいいんでしょ」  
状態で過ごしていました。

単純に知ろうとしなかったし、深く考えもしなかったので  
知るのに6年もかけてしまったという悲しい現実です。

## この記事の方針

この記事では

「staticをつけるとどうなるのか？」  
という視点ではなく

「なんでstaticとかいうものがあるの？」  
という視点で書いていきたいと思います

## 謝辞

## サンプルコードについて

説明のために、少々PHPのコードを載せていますが  
あくまでイメージのためのコードなので  
「そんな書き方おかしいだろ」という点があっても **気にしないようにしてください。**

## もろもろ簡略化しています

理解のしやすさ＆記事を書くのが大変という理由から簡略化している部分が多分にあります。  
細かいことを突っ込むと、正確ではないという部分もあるかと思いますが  
**ご容赦ください。**

では本題に入ります。

## static変数

こんなクラスがあったとします

```php
<?php
class A
{
    public $foo = 1;
    public $var = 1;
}
?>
```

クラスを書いたら、基本はnewして使います。

```php
$a = new A();
```

「クラスをnewする」というのは  
言い換えると  
「必要な分だけメモリを確保する」  
ということになります。

\*\*「new = メモリの確保」\*\*です。

以下の絵はメモリです。  
データが10個しか入らない超しょぼいメモリです。  
[![スクリーンショット 2019-06-14 7.27.51.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/57524/329f330b-a2b9-e72b-cde2-3ee2ad942277.png)](https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F57524%2F329f330b-a2b9-e72b-cde2-3ee2ad942277.png?ixlib=rb-4.0.0&auto=format&gif-q=60&q=75&s=add6002bedb2c9c78d70d2fe5d63a26f)

```php
<?php
class A
{
    public $foo = 1;
    public $var = 1;
}
?>
```

前述した、このクラスAには `$foo` と `$var` という  
２つの変数(データ)があります。

少し言い換えると  
**「このクラスはデータ2つ分のメモリが必要です。」**  
という情報が書かれているとも言えます。

事実として、 `new A()` をすると  
データ２つ分のメモリが確保されます。

メモリはこうなります。

[![スクリーンショット 2019-06-14 7.31.47.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/57524/9b452730-4db5-165c-865c-3235c824baef.png)](https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F57524%2F9b452730-4db5-165c-865c-3235c824baef.png?ixlib=rb-4.0.0&auto=format&gif-q=60&q=75&s=a9fd49003e711b8fd0828a3d7e051cd1)

- **目印** の列はわかりやすさのために書いていますが、実際のメモリに **目印** というものはありません。
- 実際のメモリにあるのはメモリの位置を表す **番号(アドレス)とデータ** のみ。

さて、クラスAをnewすることで、10個のうち２つが使われてしましました。  
使えるのは残り8個です。

---

**少し脱線した話**  
ちなみに今回newによって確保されたこのメモリですが  
このままでは解放されてしまいます。  
いわゆるGC(ガベコレ)です。

話を戻します。

---

先ほど、\*\*「new = メモリの確保」\*\*と書きましたが  
もう１つやってくれる事があります。

それは  
\*\*「確保したメモリの先頭の番号を教えてくれる」\*\*ということです。

コードを例に解説します。

```php
$a = new A();
```

このコードを補足すると、こんな具合です。

[![スクリーンショット 2019-06-14 7.45.21.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/57524/c96d4381-17cb-a948-e81e-c9f08e7e9f83.png)](https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F57524%2Fc96d4381-17cb-a948-e81e-c9f08e7e9f83.png?ixlib=rb-4.0.0&auto=format&gif-q=60&q=75&s=8e50426965fe16b5ad51d9d3791dc8df)

そしてメモリはこうなります。

[![スクリーンショット 2019-06-14 7.50.17.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/57524/0ae058e2-fff2-4526-192d-d51a86c60388.png)](https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F57524%2F0ae058e2-fff2-4526-192d-d51a86c60388.png?ixlib=rb-4.0.0&auto=format&gif-q=60&q=75&s=d7a8c91bfd8fc10779800a6e7b534099)

`$a` も変数(ローカル変数)です。  
変数は例外なくメモリを使いますので  
この１行の処理で３つもメモリを消費してしまいました。

---

**豆知識::ちょうどいいので参照という表現について解説**

`$a` という変数には\*\*「newで確保したメモリの番号」\*\*  
つまり\*\*「データの存在する場所」\*\*が記憶されています。

```php
$a->foo
```

このコードを噛み砕くと  
「 `$a` (メモリ番号1)にある `foo` に該当するデータ」  
ということになります。

「クラスは参照型だ」とよくいいますが  
**メモリの番号をもとに、実際のデータを見に行く(参照しにいく)** ので  
**参照型とか参照** という表現が使われています。

話を戻します。

---

先ほど `new A()` として、クラスAをnewしましたが  
続けてもう一回newしてみます。

```php
$a = new A();
$b = new A(); // さらにnewする
```

この時、メモリはこのようになっています。

[![スクリーンショット 2019-06-14 7.53.26.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/57524/1cfffbaa-f959-f2af-0116-a27ea2cd0017.png)](https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F57524%2F1cfffbaa-f959-f2af-0116-a27ea2cd0017.png?ixlib=rb-4.0.0&auto=format&gif-q=60&q=75&s=8a980f8da7a60d02fe1c962930e33c4c)

最初に `new` した際に、 **メモリ番号1~3を確保** しているので  
２回目の `new` では、まだ確保されていない **メモリ番号4~5** を確保します。

そして  
new「メモリ番号4から確保したよー」  
$b「おっけー、4だねー」

ということで、また3つのメモリが消費されました。  
もう残り４つしかありません。

---

**豆知識：クラスは設計図、インスタンスは実態と言われる理由**

クラスは設計図、インスタンスは実態と言われたりしますが

**クラスは**  
「クラスをnewするときにどれくらいメモリが必要になるの？」  
といった **情報が書かれているもの** に該当します。

**インスタンスは**  
**クラスに書かれた情報をもとに確保したメモリ** に該当します。

という感じなので

- クラス＝様々な情報＝設計図
- インスタンス＝実際に確保したメモリ＝実態

という表現が使われています。

はい、また話を戻します。

---

豆知識話で話が切れてしまいましたが  
ひとまず、この時点で押さえておきたい重要なポイントは

- クラスをnewするとメモリが消費されていく
- というより消費されてしまう

という事です。

**インスタンスごとに変数(メモリ)が必要** であれば  
これで別に問題ないのですが

\*\*「クラスに定数(変化させないデータ)を持たせたい！」\*\*となった場合  
このままではnewするたびに、同じデータなのにnewした分だけメモリが使われてしまいます。

これはおいしくないですね。

またnewするたびに、それぞれにメモリを確保してしまうと  
**「クラスで同じ変数(データ)を共有したい！」**  
となったときもできなくて困ってしまいます。  
(ただのグローバル変数を使うとか代替手段はありますが)

...

プログラマーたちは思いました

「この変数は１個だけでいい。。。」

「この変数はnewした時にメモリを確保してほしくない」

「この変数は何もして欲しくない。。。」

「この変数はほっておいてくれ。。。」

「この変数は静かにしておいてくれ。。。」

「この変数は何事もなく、そっとしておいてほしい。。。」

突然ですがここで英単語の勉強です。  
staticという単語ですが、これにはこんな意味があります。

> static  
> 静的、物事の状態に変化がないさま

なんと  
まさしく先ほどまでプログラマーが望んでいたことではありませんか

実際にstatic変数を定義したクラスをnewする様子をみてみましょう。

```php
<?php
class A
{
    public static $foo = 1; // fooをstaticにしました。
    public $var = 1;
}
?>
```

```php
$a = new A();
$b = new A();
```

この処理を実行したとき、メモリはどうなっているでしょうか  
こうなります。

[![スクリーンショット 2019-06-14 9.08.24.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/57524/633ed466-4123-6c8d-60ef-1a7f64157970.png)](https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F57524%2F633ed466-4123-6c8d-60ef-1a7f64157970.png?ixlib=rb-4.0.0&auto=format&gif-q=60&q=75&s=00382ed82d39208d7088d44abb0785aa)

いままで、クラスに定義した変数はnewすることでメモリが確保されていました。

逆に言えば  
newしない限り、その変数はメモリ上に存在しないので当然アクセスできません。

さらにメモリのどこに確保されるのかも、newしてみないとわかりません。  
newが、メモリを確保して、さらに「確保した場所はここだよ！」  
と教えてくれて初めてデータにアクセスすることができます。

それに対して、staticがついた変数は  
基本的にプログラムが実行されるタイミングで  
あらかじめメモリが確保されています。  
一度確保したら、プログラムが終了されるまでずっと確保されたままです。  
場所も固定されています。

つまりstatic変数は最初からメモリが確保されているし  
メモリのどこにあるかもわかっている変数ということです。  
(ぶっちゃけグローバル変数と大差ない)

なのでstaticな変数はいつでも、どこからでもアクセスできるわけです。

## static変数のまとめ

staticというのは、なんとなく変数を共通で使えるようにするもの  
というイメージを持っているかもしれません  
(というか自分がそう思っていましたし、事実そういう側面もあります)

しかしプログラムを知るにつれて  
staticというのは、変数を共通化する魔法ではなく

変数のためのメモリを、いつ、どこに確保するのか？  
を制御する魔法なのだと視点が変わりました。

些細な事かもしれませんが  
こういった視点を持てるようになってからは  
プログラマーとしての実力も伸びていったように感じています。

「でも、結局使い道としては、共通で使いたい変数にstaticをつけるだけじゃん？」  
と思ってしまったかもしれない人に向けて  
(昔の自分は思いました)

staticがついた変数と、ついていない変数では  
メモリが確保されるタイミングや、メモリのデータが初期化されるタイミングも変わってきます。

このタイミングを利用した  
Lazy Loadingとか遅延初期化といわれる  
テクニックがあったりもします。(並列処理でよく見る)

staticって奥が深いなぁと思った出来事でした。

## staticメソッド

さて、では今度はstaticメソッドについてといきたいところですが  
static変数の内容だけで結構満身創痍です。

ボリューミーな内容はまた元気が出た時にということで  
staticメソッドはさらっとまとめたいと思います。

わかりにくかったらごめんなさい。

## staticメソッドっていっても結局はただの関数

こんな関数があったとして、基本的に関数はどこからでも実行できますよね？

```php
<?php
function foo($a)
{
    print_r($a);
}
?>
```

関数というのは関数名と引数さえ合っていれば呼び出せる。

そんなの当たり前だと思うかもしれませんが  
クラスのメソッドとなると、なぜか関数と違うものと捉えてしまうのが人の脳。

関数もクラスメソッドも基本的には関数である  
という視点を持つと視界が開けるかもしれません。

## 普通のメソッド

```php
<?php
class A {
  public function foo() {
    print_r($this);
  }
}
?>
```

さて、このfoo関数の中で `$this` という変数を使っています。  
PHPerならおなじみの `$this` ですね。

しかし不思議な事にこの `$this`  
メンバ変数にも、引数にも、ローカル変数にも `$this` なんて変数は定義されていません。  
というより `$this` という変数を定義した経験がありません。

でも `$this` という変数は使えます。

つまり、誰かが `$this` という変数を用意してくれている  
`$this` が使えるように計らってくれたやつがいる

という事実があるということです。

## どうやったら$thisを使えそう？

クラスAのfooメソッドを呼ぶ処理はこう書くけど

```php
$a = new A();
$a->foo();
```

こんな風に誰かがこっそり書き換えていたとしたら

```php
$a = new A();

// ①fooの第一引数に$a渡すように書き換えてまえ
// $a->foo();
// ↓こうしてもいけるやろ
A::foo($a); 

class A {
  // ②ほんとは引数ないけど、こっそり第一引数を追加したろ
  public function foo($this) {
    print_r($this);
  }
}
```

クラスのメソッドと普通の関数の違いは  
処理の中で `$this` を使えるか、使えないかだけである。  
逆に言えば、「 `$this` が使えるということ以外は普通の関数」と同じである。

プログラムのソースコードというのはあくまでテキストファイルでしかない  
実際に動作させるには、パソコンで動作する形に変化させる必要がある。  
俗にいうコンパイルというやつでございます。。

プログラマはソースコードを書くことしかできないが  
コンパイラはそのソースコードを都合よく書き換えることができる

プログラマは `$this` なんて変数を定義してないけど  
コンパイラが `$this` という変数をこっそり定義しちゃうことはできるのだ。

勝手なことしてくれるものだ。

そもそも処理の中で `$this` を使わないのであれば  
そんな勝手なことをしてくれなくてもいいのに

何もしてくれなくていいのに。。。

そのままでいいのに。。。

突然ですがここで英単語の勉強です。  
staticという単語ですが、これにはこんな意味があります。

> static  
> 静的、物事の状態に変化がないさま

なんと  
まさしく先ほどまでプログラマーが望んでいたことではありませんか

つまりメソッドにstaticをつける＝そのメソッドはそのままでいい  
`$this` なんて渡さなくていいんだ！

という事になるわけです。

`$this` を渡さないってことは  
当然、処理のなかで `$this` なんて変数は使えませんよね？  
staticメソッド中で `$this` は使えませんよね？

## staticメソッドまとめ

かなり駆け足で雑になってしまいましたが  
何かしらの視点の変化があれば幸いです。

## まとめ

最初に申し上げた通り雑な仕上がりとなってしまいました。

やはりこういった内容を文章だけで伝えようと思うと  
非常に書くのも考えるのもしんどく

途中であぁもう書くのやめよってなることもしばしば  
今回は雑ながらも最後まで書き切れたので多少はマシですが。。。

昨今プログラマーという職業が注目され  
独学でも学べるサービスというのもたくさん溢れてきましたが

やっぱり記事より、直接教える方が楽だわーと思いました。まる。

[5](https://qiita.com/Nekonecode/items/#comments)

コメント一覧へ移動

X（Twitter）でシェアする

Facebookでシェアする

はてなブックマークに追加する

新規登録して、もっと便利にQiitaを使ってみよう

1. あなたにマッチした記事をお届けします
2. 便利な情報をあとで効率的に読み返せます
3. ダークテーマを利用できます
[ログインすると使える機能について](https://help.qiita.com/ja/articles/qiita-login-user)

[新規登録](https://qiita.com/signup?callback_action=login_or_signup&redirect_to=%2FNekonecode%2Fitems%2F19f3a261a8391853ddec&realm=qiita) [ログイン](https://qiita.com/login?callback_action=login_or_signup&redirect_to=%2FNekonecode%2Fitems%2F19f3a261a8391853ddec&realm=qiita)

この記事は以下の記事からリンクされています

- [【C#】staticっていつ使えばいいの？何がいいの？](https://qiita.com/tkhshiq/items/ae431e6e4948dfff929c)

## Qiita Advent Calendar 開催！

[171](https://qiita.com/Nekonecode/items/19f3a261a8391853ddec/likers)

いいねしたユーザー一覧へ移動

142