---
title: "OpenCVのcv::Matに関する小ネタ集"
source: "https://recruit-preview.cct-inc.co.jp/tecblog/img-processor/opencv_cvmat/"
author:
published: 2023-12-25
created: 2025-08-21
description: "今回は、C++でOpenCVのcv::Matを使う際の小ネタ集である。以下の小ネタを扱う。C++で書く時のOpenCVの小ネタを集めた。コピーや参照、ポインタなどの振る舞いはPythonではあまり表に出てこないが大切な概念である。また、深層学習を行う際はcv::Matへの画像格納方法が通常と異なることに注意しなければならない。Python版のOpenCVであれば画像は全てnumpyのarrayに格納されるので、画像処理と深層学習の間で画像の持ち方に大きな違いはない。後者の場合にバッチサイズ用に次元が1つ増えるだけである。"
tags:
  - "clippings"
---
## はじめに

今回は、C++でOpenCVのcv::Matを使う際の小ネタ集である。以下の小ネタを扱う。

1. 画素へのアクセス
2. BGRの謎
3. 演算子のオーバーロード
4. ROIの抽出
5. Blobの作成

cv::Matとは、画像を保持する22の行列を表すクラスである。

## 検証環境

1. OS: Windows11 Pro
2. プロセッサ: Intel(R) Core i7 2.80 GHz
3. RAM: 16GB

## 1\. 画素へのアクセス

最初に取り上げる話題は画素へのアクセスの仕方だ。画像の各画素にアクセスする方法として次の3つを考えることができる。

- atメソッドを使う。
- ポインタを使う。
- イテレータを使う。

順にサンプルコードを見ていく。

#### atメソッドを使う

| 1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29 | //  // atを用いた実装  }  }  } |
| --------------------------------------------------------------------------------------------------------- | ------------------------ |
|                                                                                                           |                          |

4行目と5行目で入力画像の行数 `rows` と列数 `cols` を取得している。8行目で出力画像を格納する箱を用意する。 `CV_8UC3` は符号なし8ビット・3チャンネルを指定する識別子である。ループの中では全画素値の置き換えをしている。13行目と26行目でcv::Matの `at` メソッドを使っている。 `at` メソッドの呼び出しごとに境界チェック（画像外をアクセスしていないか）が行われるため、実行速度は遅くなる。

#### ポインタを使う

| 1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28 | //  // pointerを用いた実装  }  }  } |
| --- | --- |

cv::Matの `ptr` メソッドを使い、9行目で入力画像のポインタを、10行目で出力画像のポインタを取得している。この2つのポインタはどちらもj行目の画像の先頭を指す。12行目と25行目でi列目の画素値にアクセスしている。ループの中でしていることはatメソッドのときと同じである。アクセス時に境界チェックは行われないので高速である。ただし、画像のメモリレイアウトを正確に把握しておく必要がある。

#### イテレータを使う

| 1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31 | //  // iteratorを用いた実装  ++ src\_it;  ++ dst\_it;  }  } |
| --- | --- |

8行目から10行目でcv::Matの `begin` メソッドと `end` メソッドを使いイテレータを取得している。これを使い左上から右下に向けて直線的に画素にアクセスする。イテレータの場合はatメソッドの時と同様に境界チェックが行われるためオーバヘッドがある。

#### 速度比較

30003000の画像の全画素の更新を100回行い平均を取った処理速度は以下の通り。予想通りポインタ版が最も速い。イテレータ版が最も遅いのは少し意外であった。

![](https://recruit-preview.cct-inc.co.jp/wp-content/uploads/2023/12/2d5bdc543398e500e146c767ca689421.jpg)

図1

## 2\. BGRの謎

次の話題は「なぜOpenCVの画素の並びはRGBではなくBGRなのか」だ。

| 1  2  3  4  5  6  7  8  9  10  11  12  13 | //  } |
| --- | --- |

9行目から11行目でBGRの順に値を取り出している。この並びである理由の1つとして、OpenCVの前身であるIPL（Image Processing Library）での並びがBGRであったためであると言われている。IPLはもともとWindows用であり、Windowsでは内部画像形式としてDIB（Device Independent Bitmap）が使われていた。DIBの画素の並びはBGRである。他にもいろいろな説があるので興味がある方は [こちら](https://qiita.com/yoya/items/bfef7404ded22649a2af) を参照してほしい。

## 3\. 演算子のオーバーロード

次の話題は演算子のオーバーロードである。以下のコードに見るようにcv::Matのインスタンスを普通の数字のように使い四則演算を行うことができる。

| 1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25 | //  {  }  {  }  {  }  } |
| --- | --- |

3行目と4行目で22行列 `x` と `y` を作成している。 `x` の成分は全て1に、 `y` の成分は全て2に初期化している。6行目以降に示した3つの演算子「+」「-」「\*」の実装には式テンプレート（Expression Template）という手法が使われる。この手法は、式全体を1つのオブジェクトとして表現し、実際に計算が必要になるまでその評価を遅らせる方法である（遅延評価と呼ばれる）。上の例で言えば、9行目、15行目、21行目で初めて数値を用いた計算が実行される。演算「\*」は行列同士の積である。出力結果は以下の通り。

![](https://recruit-preview.cct-inc.co.jp/wp-content/uploads/2024/01/35d5f162d550b82daf1b64e1885a1e4b.jpg)

図2

このテクニックにより、計算の過程で発生する一時オブジェクトの生成を避けることができ、パフォーマンスの向上を期待できる。上のコードに挙げた例以外に、割り算（/）や各種不等号もサポートされる。サポートされる演算の一覧は [こちらのAPIドキュメント](https://docs.opencv.org/4.x/d1/d10/classcv_1_1MatExpr.html) を見てほしい。

## 4\. ROIの抽出

次の話題はROI（Region Of Interest）の抽出である。画像内の任意の矩形領域を抽出する処理である。

| 1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39  40  41  42 | //  fill\_with\_black (roi);  cv::waitKey (0);  }  }  }  } |
| --- | --- |

18行目でROIを抽出し変数 `roi` に代入している。抽出される画像内の場所は11行目から15行目で指定される。 `roi` は画像内の矩形領域のコピーでなく参照であるため、21行目でこの領域を黒く塗りつぶすと元画像 `image` の対応する領域も黒になる。図2の左は黒く塗りつぶす前の画像、右は `roi` を黒く塗りつぶした後の `image` である（画像は [こちら](http://www.ess.ic.kanagawa-it.ac.jp/app_images_j.html#image_dl) からダウンロードした）。

![](https://recruit-preview.cct-inc.co.jp/wp-content/uploads/2023/12/755e03d3adf7ce7c552ccc91a4014639.jpg)

図2

参照ではなくコピーが欲しい場合は、18行目の右辺を `image(roi).clone()` とすれば良い。

## 5\. Blobの作成

最後の話題は、深層学習の入力（Blobと呼ばれる）についてだ（OpenCVを用いた深層学習については前回のブログで解説した）。深層学習の入力は普通の画像とは異なる形式でcv::Matに格納される。

| 1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54  55  56  57  58 | //  }  cv::waitKey (0);  } |
| --- | --- |

7行目作られるcv::Matのインスタンス `originalImage` は通常のフォーマットで画像を格納する。13行目から15行目で高さ、幅、チャンネル数を表示している。20行目から25行目でBlobを作成する準備をし、26行目の `cv::dnn::blobFromImages` でBlob `inputBlog` を作成している。Blogの情報は28行目から32行目のようにして取得する。 `inputBlob.size` の中に(batch\_size,channels,height,width)の順に格納されている。bach\_sizeが2となる理由は、25行目で2枚の画像を与えているからである。通常の画像のように情報を取得すると（34 行目から36行目）無効な値が返るので注意が必要である。画像1枚のときのメモリレイアウトを図3に示す。

![](https://recruit-preview.cct-inc.co.jp/wp-content/uploads/2023/12/d00acf9f1a60bea4a637b283562775a3.jpg)

図3

3つのチャンネルが別々に格納されているので、通常のレイアウトに戻すには、38行目から52行目のようにひと手間が必要である。画像表示関数 `cv::imshow` （55行目）に渡せるのは通常のレイアウトを持つcv::Matだけである。

## まとめ

今回は、C++で書く時のOpenCVの小ネタを集めた。コピーや参照、ポインタなどの振る舞いはPythonではあまり表に出てこないが大切な概念である。また、深層学習を行う際はcv::Matへの画像格納方法が通常と異なることに注意しなければならない。Python版のOpenCVであれば画像は全てnumpyのarrayに格納されるので、画像処理と深層学習の間で画像の持ち方に大きな違いはない。後者の場合にバッチサイズ用に次元が1つ増えるだけである。

## 参考文献

- [OpenCV のピクセル形式がBGRである理由](https://qiita.com/yoya/items/bfef7404ded22649a2af)
- 【オウム画像の引用元】Webサイト名：神奈川工科大学 情報学部 情報工学科,  
	URL： [http://www.ess.ic.kanagawa-it.ac.jp/app\_images\_j.html#image\_dl](http://www.ess.ic.kanagawa-it.ac.jp/app_images_j.html#image_dl)
- [OpenCVではじめよう ディープラーニングによる画像認識](https://gihyo.jp/book/2022/978-4-297-12775-6)